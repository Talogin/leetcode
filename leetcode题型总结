1.priority_queue求解k closest问题
  703   设计class，单纯用min_heap求stream中第k大的数
  973   单纯利用priority_queue求解离(0, 0)最近的k个点集合
  
  
2.binary search及其变形
  33    有rotation的binary search
  278   binary search变形，比较条件改为已知函数判断。
  367   binary search变形，比较的条件进行了变形，是用平方进行比较，需要注意溢出
  658   binary search变形，利用已排序数组特性求区间的左起点
  704   最一般形式binary search，可以经常复习一下，毕竟不一定完全写的对
  
3.DFS
  47    permutation题
  200   island小岛题，这题不用另外地弄一个visited，直接讲访问过的点改成'0'就行了
  211   Trie Tree和DFS的一个结合
  247   permutation变形题
  261   Graph Valid Tree树找环问题
  294   游戏题
  320   类似permutaion题
  366   Find Leaves of Binary Tree, 是用vector去存储树的节点，有点类似于按列输出树节点那道题
  733   类似于island的变形，但这题可以不用visited
  

4.BFS
  127   需要根据string间的关系构建节点之间关系，然后进行BFS操作。
  286   二维数组形式的BFS

5.DP
  139   Word Break
  221   用dp，input为二维数组
  279   类似0-1背包问题
  322   0-1背包问题
  
6.BST
  94    inorder遍历，递归迭代写法
  230   就是preorder遍历，有递归和迭代两种写法
  285   BST的二叉搜索
  333   Largest BST Subtree BST的从下向上式判断
  530
  783   530和783两题基本一样，就是求BST中两数最小的差。记住BST中两数最小差就是进行树的中序遍历。所以这两题也可以看成是树的中序遍历题。
        中序遍历又涉及到递归方法和迭代方法。而迭代方法又基本得用到stack
        
7.字符串分割
  819   常规的对字符串进行处理，分割出word，这类题corner case比较多，比如字符串开头一大堆的空格，标点等，然后word之间也有一堆的空白和标点，然后
        最后是以字母结尾，需要对最后一个word进行额外处理等等。这些需要好好训练
        
8.链表
  2     和21有些类似，方法也是比较经典
  21    经典的处理链表问题，方法很巧妙，处理corner case的一个很好的方法
  369   Plus One Linked List  链表操作

9.贪心
  253   比较简单的贪心问题
