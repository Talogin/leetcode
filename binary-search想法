如果是单纯地利用binary-search在一个数组中找到target，如果不存在就返回-1，那么这种情况下判断条件应该为if(lo <= hi)，因为你是要判断存不存在，当不断
地循环之后，（而且hi在这里是要等于mid-1的，因为mid不相等了，那么显然mid就不在下一轮的搜索范围内了，所以hi = mid-1）将搜索范围缩小到只有一个元素的时
候，也就是lo == hi的时候，你还得再进行一轮，去判断这单一元素是否等于target。
但是如果遇到一点变形，比如说436题中寻找满足条件的最...的元素时，那么有时候，你就要根据具体情况去写判断条件，以及去写lo和hi的赋值语句。拿436来举例，这
题中是要寻找大于等于end的最小start，也就相当于寻找大于等于一个数的最小数，那么判断条件我们这儿写成if(lo < hi)，因为这样可以返回一个结果，就是最后low
与high共同指向的那个元素。这儿还需要进行一轮进行判断吗？视具体情况而定。其实上面的lo <= hi是可以改写成lo < hi的，不过就是循环结束后，对low与high指向
的那个元素进行一个判断，判断是否等于target。而在436中，进行的判断就是看最后的那个元素的start是否大于target.end。其实说白了道理是共同的。
binary-search有一个需要注意的点，就是如果lo = mid，这有可能造成无限循环的。比如说给一个数组，找出小于target的最大数的index，在这种情况下，代码就如下
if(lo < hi) {
  int mid = lo + (hi-lo)/2;
  if(arr[mid] <= target)
    lo = mid;
  else 
    hi = mid - 1;
}
比如说给一个数组【1，3，5，6，8】，target为4，那么会造成无限循环。
但是可以进行一些改变，比如把这题等价于寻找大于target的最小，那么代码就会发生改变，这就类似于436了。然后找到的这个数左边的那个数就是要找的数了。
