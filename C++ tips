1.stack
    stack<Type> stk;
    stk.size();
    stk.top();
    stk.pop();  删除元素并不会返回值
    stk.push();
    
2.priority_queue
    priority_queue默认构建的是max_heap
    第一个参数是数据类型，第二个参数是保存数据的容器，第三个参数为比较的方式。
    搭建存储pair的min_heap
    priority_queue<pair<int,int>, vector<pair<int,int>>, greator<pair<int,int>> pq;
    pq.push();
    pq.top();
    pq.pop();
    
    也可以自定义比较函数
    using mp = pair<int, int>;
    auto f = [](mp &p1, mp &p2){ return p1.first > p2.first;};
    priority_queue<mp, vector<mp>, decltype(f)> pq(f);
    
    也可以自定义一个比较类
    class Solution {
    public:
        vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {
            priority_queue<vector<int>, vector<vector<int>>, Compare> pq(points.begin(), points.end());
            vector<vector<int>> ans;
            for (int i = 0; i < K; i++) {
                ans.push_back(pq.top());
                pq.pop();
            }
            return ans;
        }
    private:
        struct Compare {
            bool operator()(const vector<int>& p, const vector<int>& q) {
                return p[0] * p[0] + p[1] * p[1] > q[0] * q[0] + q[1] * q[1];
            }
        };
    };
    

3.make_pair
    pair<int, int> p(1,1);
    pq.push(make_pair(p.second, p.first);
    或
    pq.push({p.second, p.first});
    
4.stoi & to_string
    stoi(str):string转int；
    to_string(i):int转string；

5.(expression) ? ++i : --j;
    3sum中需要根据当前的和sum与target之间的大小关系来选择是++start还是--end，那么可以利用这么一个小语句。
    (sum < target) ? ++start : --end;

6.vector erase & find
    vector<int> vec;
    vec.erase(vec.begin()+i) : 删除index为i的元素
    vec.erase(vec.begin()+i, vec.begin()+j) : 删除index为i和j之间的元素，不包括元素j
    find(vec.begin(), vec.end(), x) != vec.end(): 看vec中是否包含x，如果不包含就返回vec.end()
    
7.switch
    使用switch(state)时，state必须是可以唯一转换成integer的数据类型，比如int, char.所以并不可以直接用string作为state.最好写的时候还是用
    if-else.
    
