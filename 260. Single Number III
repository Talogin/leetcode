class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        int sum = 0;
        for(int i = 0; i < nums.size(); i++) {
            sum ^= nums[i];
        }
        
        sum &= (~sum+1);
        vector<int> res(2);
        for(int i = 0; i < nums.size(); i++) {
            if((nums[i] & sum) == 0) {
                res[0] ^= nums[i];
            } else {
                res[1] ^= nums[i];
            }
        }
        return res;
    }
};

思路：
  这道题和136 single number很像，但是现在是有两个只出现过一次的数了，那怎么解？
  将它分成两部分，每个部分分别包含一个只出现过一次的数，那就又变成了136题了。
  有几个写法很值得学习，一个是第9行，它的作用是我知道了这两个数的异或值，然后对这个值进行一个如下的操作：从右向左，找到第一个为1的数，将它设为1，其他位
  全都设为0.比如这个值为bbb100（b随意为0或1），那么首先进行~取反，那就变成aaa011（a为~b)，然后加1，就变成aaa100，那么与原数相与，就能得到我们上面
  想要的那个值了。
  得到这个数之后有什么用呢，我们知道异或值就是某一位这两个数相同为0，不同为1，那么从右往左的第一位为1的保留为1，其他均置零，那么这两个数与它相与，其他
  位肯定两数都为0，但是为1的那位，因为异或值那位也为1，就说明这两个数这一位不同，那与1相与，一定一个为0，一个为1，那整个相与的结果就是一个为0，一个不
  为0.
