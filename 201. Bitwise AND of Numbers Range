class Solution {
public:
    int rangeBitwiseAnd(int m, int n) {
        int mask = 1;
        while(m != n) {
            m >>= 1;
            n >>= 1;
            mask <<= 1;
        }
        return m * mask;
    }
};

这个题目我拿到手的时候，我是想着能不能找到什么比较好的规律去简单地计算。当时找到的一个规律就是奇数和偶数AND运算后，得到的结果末尾为0.也就相当于奇数与偶数
AND运算后得到偶数本身，然后呢？留下的那些偶数之间怎么运算呢？它们之间AND运算就没有什么很明确的规律了。但是，可以换个角度去看，你上一步将所有奇数剔除之后
相当于将最后一位处理完了，那么接下来的运算就不用管最后一位了，那么我们看倒数第二位，将倒数第二位看成刚才的最后一位去处理，这就相当于对剩下的所有偶数同时
右移一位，除了一个2，那么从这个角度去看，就不全是偶数了，比如6，只看倒数第二位，最后一位不看，相当于是除了个2，就是3了，就不是偶数了，这时候就是奇数，那
它倒数第二位上应该是1，如果是4，那么除一个2，还是2，偶数，那么第二位上应该是0，所以第二位AND操作，仍然可以根据奇数偶数AND为0来做。依次计算到最高位。
那么每次我们都将m,n都向右移一位，只要它们不相等，就说明那一位上有一对奇数和偶数，那么那位必然为0，然后一直计算到某一位，它的左边高位上m和n都相等。
值得注意的是，最后mask和m之间是乘法运算。你仔细体会下，m最后可能是111这样的形式，然后mask最后比如说是1000，那么最后返回结果是111000，你可能直觉地认为
大概要算下mask是移动了几位，然后将111向左移动相应位数，但其实bit操作，这种直接相乘就行了。
